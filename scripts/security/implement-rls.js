#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Colors for console output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m'
};

function log(message, color = 'reset') {
  const timestamp = new Date().toISOString();
  console.log(`${colors[color]}[${timestamp}] ${message}${colors.reset}`);
}

function executeSupabaseSQL(sqlCommands) {
  try {
    log('üîß Executing RLS implementation via Supabase CLI...', 'blue');
    log('===============================================', 'blue');
    
    // Create a temporary SQL file
    const tempSqlFile = path.join(__dirname, '../../temp-rls-implementation.sql');
    fs.writeFileSync(tempSqlFile, sqlCommands);
    
    log('üìù Created temporary SQL file:', 'cyan');
    log(`   ${tempSqlFile}`, 'blue');
    
    // Execute SQL using Supabase CLI
    log('üöÄ Executing SQL commands...', 'blue');
    
    const result = execSync(
      `npx supabase db push --db-url "${process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:54322/postgres'}"`,
      {
        cwd: path.join(__dirname, '../../supabase'),
        encoding: 'utf8',
        input: sqlCommands,
        stdio: ['pipe', 'pipe', 'pipe']
      }
    );
    
    log('‚úÖ RLS implementation completed!', 'green');
    log('üìä Result:', 'cyan');
    console.log(result);
    
    // Clean up temp file
    fs.unlinkSync(tempSqlFile);
    log('üßπ Cleaned up temporary files', 'green');
    
    return true;
    
  } catch (error) {
    log(`‚ùå Error executing RLS implementation: ${error.message}`, 'red');
    log('üí° Alternative approach needed - using SQL file method', 'yellow');
    return false;
  }
}

function createRLSSQL() {
  const rlsSQL = `-- Enable Row Level Security (RLS) on Critical Tables
-- Generated by Security Implementation Script

-- Step 1: Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_variants ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;

-- Step 2: Drop existing policies (if any)
DROP POLICY IF EXISTS "Users can view own profile" ON users;
DROP POLICY IF EXISTS "Users can update own profile" ON users;
DROP POLICY IF EXISTS "Users can view own orders" ON orders;
DROP POLICY IF EXISTS "Users can manage own cart" ON cart_items;
DROP POLICY IF EXISTS "Products are publicly viewable" ON products;
DROP POLICY IF EXISTS "Product variants are publicly viewable" ON product_variants;
DROP POLICY IF EXISTS "Categories are publicly viewable" ON categories;

-- Step 3: Create restrictive RLS policies

-- Users table - Users can only access their own data
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE
  USING (auth.uid() = id);

-- Orders table - Users can only access their own orders
CREATE POLICY "Users can view own orders" ON orders
  FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own orders" ON orders
  FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own orders" ON orders
  FOR UPDATE
  USING (user_id = auth.uid());

-- Cart items table - Users can only manage their own cart
CREATE POLICY "Users can view own cart" ON cart_items
  FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own cart" ON cart_items
  FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own cart" ON cart_items
  FOR UPDATE
  USING (user_id = auth.uid());

CREATE POLICY "Users can delete own cart" ON cart_items
  FOR DELETE
  USING (user_id = auth.uid());

-- Products table - Public read access (for browsing)
CREATE POLICY "Products are publicly viewable" ON products
  FOR SELECT
  USING (is_active = true);

-- Product variants table - Public read access
CREATE POLICY "Product variants are publicly viewable" ON product_variants
  FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM products p 
    WHERE p.id = product_variants.product_id 
    AND p.is_active = true
  ));

-- Categories table - Public read access
CREATE POLICY "Categories are publicly viewable" ON categories
  FOR SELECT
  USING (true);

-- Step 4: Revoke public access from sensitive tables
REVOKE ALL ON TABLE orders FROM PUBLIC;
REVOKE ALL ON TABLE cart_items FROM PUBLIC;
REVOKE ALL ON TABLE users FROM PUBLIC;

-- Step 5: Grant necessary permissions to authenticated users
GRANT SELECT ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT INSERT ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT UPDATE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT DELETE ON ALL TABLES IN SCHEMA public TO authenticated;

-- Step 6: Create admin role policies (for admin users)
CREATE POLICY "Admins can manage all users" ON users
  FOR ALL
  USING (
    auth.jwt() ->> 'role' = 'admin' OR 
    auth.jwt() ->> 'app_metadata' ->> 'role' = 'admin'
  )
  WITH CHECK (true);

CREATE POLICY "Admins can manage all orders" ON orders
  FOR ALL
  USING (
    auth.jwt() ->> 'role' = 'admin' OR 
    auth.jwt() ->> 'app_metadata' ->> 'role' = 'admin'
  )
  WITH CHECK (true);

CREATE POLICY "Admins can manage all cart" ON cart_items
  FOR ALL
  USING (
    auth.jwt() ->> 'role' = 'admin' OR 
    auth.jwt() ->> 'app_metadata' ->> 'role' = 'admin'
  )
  WITH CHECK (true);

CREATE POLICY "Admins can manage all products" ON products
  FOR ALL
  USING (
    auth.jwt() ->> 'role' = 'admin' OR 
    auth.jwt() ->> 'app_metadata' ->> 'role' = 'admin'
  )
  WITH CHECK (true);

CREATE POLICY "Admins can manage all categories" ON categories
  FOR ALL
  USING (
    auth.jwt() ->> 'role' = 'admin' OR 
    auth.jwt() ->> 'app_metadata' ->> 'role' = 'admin'
  )
  WITH CHECK (true);

-- Step 7: Security verification queries
SELECT 
  '=== RLS IMPLEMENTATION VERIFICATION ===' as section,
  '' as blank1,
  'Verification' as table_type,
  tablename,
  rowsecurity as rls_enabled,
  (SELECT COUNT(*) FROM pg_policies WHERE schemaname = 'public' AND tablename = t.tablename) as policy_count
FROM pg_tables t
WHERE t.schemaname = 'public'
  AND t.tablename IN ('users', 'orders', 'cart_items', 'products', 'product_variants', 'categories')
ORDER BY tablename;`;

  return rlsSQL;
}

function tryAlternativeApproach() {
  log('üîÑ Trying alternative CLI approaches...', 'yellow');
  log('=====================================', 'yellow');
  
  const sqlCommands = createRLSSQL();
  
  // Method 1: Try using supabase db push with migration
  try {
    log('üìã Method 1: Creating migration file...', 'blue');
    const migrationDir = path.join(__dirname, '../../supabase/migrations');
    
    if (!fs.existsSync(migrationDir)) {
      fs.mkdirSync(migrationDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace(/\..*/, '');
    const migrationFile = path.join(migrationDir, `${timestamp}_enable_rls.sql`);
    fs.writeFileSync(migrationFile, sqlCommands);
    
    log(`‚úÖ Created migration file: ${migrationFile}`, 'green');
    
    log('üöÄ Running supabase db push...', 'blue');
    const pushResult = execSync('npx supabase db push', {
      cwd: path.join(__dirname, '../../supabase'),
      encoding: 'utf8'
    });
    
    console.log(pushResult);
    log('‚úÖ Migration pushed successfully!', 'green');
    return true;
    
  } catch (error) {
    log(`‚ùå Migration approach failed: ${error.message}`, 'red');
  }
  
  // Method 2: Try using psql directly if DATABASE_URL is available
  try {
    if (process.env.DATABASE_URL) {
      log('üìã Method 2: Using psql directly...', 'blue');
      
      const psqlResult = execSync(
        `psql "${process.env.DATABASE_URL}" -f "${path.join(__dirname, '../../temp-rls-implementation.sql')}"`,
        { encoding: 'utf8' }
      );
      
      console.log(psqlResult);
      log('‚úÖ SQL executed via psql!', 'green');
      return true;
    }
  } catch (error) {
    log(`‚ùå psql approach failed: ${error.message}`, 'red');
  }
  
  return false;
}

function main() {
  const command = process.argv[2] || 'implement';
  
  log('üîí RLS Implementation via CLI', 'blue');
  log('=============================', 'blue');
  
  switch (command) {
    case 'implement':
    case 'run':
      const sqlCommands = createRLSSQL();
      
      // Save SQL to file for reference
      const sqlFile = path.join(__dirname, '../../scripts/security/enable-rls.sql');
      fs.writeFileSync(sqlFile, sqlCommands);
      log(`üíæ SQL commands saved to: ${sqlFile}`, 'green');
      
      // Try to execute via CLI
      const success = executeSupabaseSQL(sqlCommands);
      
      if (!success) {
        log('üîÑ Trying alternative approaches...', 'yellow');
        tryAlternativeApproach();
      }
      
      break;
      
    case 'verify':
      log('üîç Verifying RLS implementation...', 'blue');
      try {
        const verifyResult = execSync('npx supabase db shell -c "SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = \'public\' ORDER BY tablename;"', {
          cwd: path.join(__dirname, '../../supabase'),
          encoding: 'utf8'
        });
        console.log(verifyResult);
      } catch (error) {
        log(`‚ùå Verification failed: ${error.message}`, 'red');
      }
      break;
      
    default:
      log('üìñ Usage:', 'blue');
      log('  node implement-rls.js implement  - Implement RLS via CLI', 'cyan');
      log('  node implement-rls.js verify     - Verify RLS implementation', 'cyan');
      break;
  }
}

if (require.main === module) {
  main();
}

module.exports = {
  createRLSSQL,
  executeSupabaseSQL,
  tryAlternativeApproach
};
